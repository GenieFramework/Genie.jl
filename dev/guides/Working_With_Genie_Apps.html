<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Working with Genie Apps · Genie - The Highly Productive Julia Web Framework</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">Genie - The Highly Productive Julia Web Framework</a></span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><span class="tocitem">Guides</span><ul><li class="is-active"><a class="tocitem" href="Working_With_Genie_Apps.html">Working with Genie Apps</a><ul class="internal"><li><a class="tocitem" href="#Working-with-resources"><span>Working with resources</span></a></li><li><a class="tocitem" href="#Using-Controllers"><span>Using Controllers</span></a></li><li><a class="tocitem" href="#Setup-the-route"><span>Setup the route</span></a></li><li><a class="tocitem" href="#Views"><span>Views</span></a></li><li><a class="tocitem" href="#Accessing-databases-with-SearchLight-models"><span>Accessing databases with <code>SearchLight</code> models</span></a></li><li><a class="tocitem" href="#Congratulations"><span>Congratulations</span></a></li></ul></li><li><a class="tocitem" href="Interactive_environment.html">Using Genie in an interactive environment</a></li><li><a class="tocitem" href="Simple_API_backend.html">Developing an API backend</a></li><li><a class="tocitem" href="Genie_Plugins.html">Using Genie Plugins</a></li><li><a class="tocitem" href="Working_With_Genie_Apps_Intermediary_Topics.html">Working With Genie Apps: Intermediate Topics [WIP]</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/1--Overview.html">Welcome to Genie</a></li><li><a class="tocitem" href="../tutorials/2--Installing_Genie.html">Installing Genie</a></li><li><a class="tocitem" href="../tutorials/3--Getting_Started.html">Getting started</a></li><li><a class="tocitem" href="../tutorials/4--Developing_Web_Services.html">Creating a web service</a></li><li><a class="tocitem" href="../tutorials/4-1--Developing_MVC_Web_Apps.html">Developing MVC web applications</a></li><li><a class="tocitem" href="../tutorials/5--Handling_Query_Params.html">Handling URI/query params</a></li><li><a class="tocitem" href="../tutorials/6--Working_with_POST_Payloads.html">Working with forms and POST payloads</a></li><li><a class="tocitem" href="../tutorials/7--Using_JSON_Payloads.html">Using JSON payloads</a></li><li><a class="tocitem" href="../tutorials/8--Handling_File_Uploads.html">Uploading files</a></li><li><a class="tocitem" href="../tutorials/9--Publishing_Your_Julia_Code_Online_With_Genie_Apps.html">Adding your libraries into Genie</a></li><li><a class="tocitem" href="../tutorials/10--Loading_Genie_Apps.html">Loading and starting Genie apps</a></li><li><a class="tocitem" href="../tutorials/11--Managing_External_Packages.html">Managing Genie app&#39;s dependencies</a></li><li><a class="tocitem" href="../tutorials/12--Advanced_Routing_Techniques.html">Advanced routing</a></li><li><a class="tocitem" href="../tutorials/13--Initializers.html">Auto-loading configuration code with initializers</a></li><li><a class="tocitem" href="../tutorials/14--The_Secrets_File.html">The secrets file</a></li><li><a class="tocitem" href="../tutorials/15--The_Lib_Folder.html">Auto-loading user libraries</a></li><li><a class="tocitem" href="../tutorials/16--Using_Genie_With_Docker.html">Using Genie with Docker</a></li><li><a class="tocitem" href="../tutorials/17--Working_with_Web_Sockets.html">Working with WebSockets</a></li><li><a class="tocitem" href="../tutorials/80--Force_Compiling_Routes.html">Force compiling route handlers</a></li><li><a class="tocitem" href="../tutorials/90--Deploying_With_Heroku_Buildpacks.html">Deploying to Heroku with Buildpacks</a></li><li><a class="tocitem" href="../tutorials/91--Deploying_Genie_Docker_Apps_on_Heroku.html">Deploying to Heroku with Docker</a></li><li><a class="tocitem" href="../tutorials/92--Deploying_Genie_Server_Apps_with_Nginx.html">Deploying to server with Nginx</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../API/app.html">App</a></li><li><a class="tocitem" href="../API/appserver.html">AppServer</a></li><li><a class="tocitem" href="../API/assets.html">Assets</a></li><li><a class="tocitem" href="../API/cache.html">Cache</a></li><li><a class="tocitem" href="../API/commands.html">Commands</a></li><li><a class="tocitem" href="../API/configuration.html">Configuration</a></li><li><a class="tocitem" href="../API/cookies.html">Cookies</a></li><li><input class="collapse-toggle" id="menuitem-4-8" type="checkbox"/><label class="tocitem" for="menuitem-4-8"><span class="docs-label">Deploy</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../API/deploy_docker.html">Docker</a></li><li><a class="tocitem" href="../API/deploy_heroku.html">Heroku</a></li></ul></li><li><a class="tocitem" href="../API/encryption.html">Encryption</a></li><li><a class="tocitem" href="../API/exceptions.html">Exceptions</a></li><li><a class="tocitem" href="../API/filetemplates.html">FileTemplates</a></li><li><a class="tocitem" href="../API/flash.html">Flash</a></li><li><a class="tocitem" href="../API/generator.html">Generator</a></li><li><a class="tocitem" href="../API/genie.html">Genie</a></li><li><a class="tocitem" href="../API/headers.html">Headers</a></li><li><a class="tocitem" href="../API/httputils.html">HttpUtils</a></li><li><a class="tocitem" href="../API/input.html">Input</a></li><li><a class="tocitem" href="../API/plugins.html">Plugins</a></li><li><a class="tocitem" href="../API/renderer.html">Renderer</a></li><li><a class="tocitem" href="../API/renderer_html.html">HTML Renderer</a></li><li><a class="tocitem" href="../API/renderer_js.html">JS Renderer</a></li><li><a class="tocitem" href="../API/renderer_json.html">JSON Renderer</a></li><li><a class="tocitem" href="../API/requests.html">Requests</a></li><li><a class="tocitem" href="../API/responses.html">Responses</a></li><li><a class="tocitem" href="../API/router.html">Router</a></li><li><a class="tocitem" href="../API/sessions.html">Sessions</a></li><li><a class="tocitem" href="../API/toolbox.html">Toolbox</a></li><li><a class="tocitem" href="../API/util.html">Util</a></li><li><a class="tocitem" href="../API/webchannels.html">WebChannels</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Guides</a></li><li class="is-active"><a href="Working_With_Genie_Apps.html">Working with Genie Apps</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="Working_With_Genie_Apps.html">Working with Genie Apps</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/GenieFramework/Genie.jl/blob/master/docs/src/guides/Working_With_Genie_Apps.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Working-with-Genie-apps-(projects)"><a class="docs-heading-anchor" href="#Working-with-Genie-apps-(projects)">Working with Genie apps (projects)</a><a id="Working-with-Genie-apps-(projects)-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-Genie-apps-(projects)" title="Permalink"></a></h1><p>Working with Genie in an interactive environment can be useful – but usually we want to persist the application and reuse it between sessions. One way to achieve this is to save it as an IJulia notebook and rerun the cells.</p><p>However, you can get the best of Genie by working with Genie apps. A Genie app is a MVC (Model-View-Controller) web application which promotes the convention-over-configuration principle. By working with a few predefined files, within the Genie app structure, the framework can lift a lot of weight and massively improve development productivity. But following Genie&#39;s workflow, one instantly gets, out of the box, features like automatic module loading and reloading, dedicated configuration files, logging, support for environments, code generators, caching, support for Genie plugins, and more.</p><p>In order to create a new Genie app, we need to run <code>Genie.newapp($app_name)</code>:</p><pre><code class="language-julia hljs">julia&gt; Genie.newapp(&quot;MyGenieApp&quot;)</code></pre><p>Upon executing the command, Genie will:</p><ul><li>make a new dir called <code>MyGenieApp</code> and <code>cd()</code> into it,</li><li>install all the app&#39;s dependencies,</li><li>create a new Julia project (adding the <code>Project.toml</code> and <code>Manifest.toml</code> files),</li><li>activate the project,</li><li>automatically load the new app&#39;s environment into the REPL,</li><li>start the web server on the default Genie port (port 8000) and host (127.0.0.1).</li></ul><p>At this point you can confirm that everything worked as expected by visiting <a href="http://127.0.0.1:8000">http://127.0.0.1:8000</a> in your favourite web browser. You should see Genie&#39;s welcome page.</p><p>Next, let&#39;s add a new route. Routes are used to map request URLs to Julia functions. These functions provide the response that will be sent back to the client. Routes are meant to be defined in the dedicated <code>routes.jl</code> file. Open <code>MyGenieApp/routes.jl</code> in your editor or run the following command (making sure that you are in the app&#39;s directory):</p><pre><code class="language-julia hljs">julia&gt; edit(&quot;routes.jl&quot;)</code></pre><p>Append this at the bottom of the <code>routes.jl</code> file and save it:</p><pre><code class="language-julia hljs"># routes.jl
route(&quot;/hello&quot;) do
  &quot;Welcome to Genie!&quot;
end</code></pre><p>We are using the <code>route</code> method, passing in the &quot;/hello&quot; URL and an anonymous function which returns the string &quot;Welcome to Genie!&quot;. What this means is that for each request to the &quot;/hello&quot; URL, our app will invoke the route handler function and respond with the welcome message.</p><p>Visit <a href="http://127.0.0.1:8000/hello">http://127.0.0.1:8000/hello</a> for a warm welcome!</p><hr/><p><strong>HEADS UP</strong></p><p>In case you pick this up some time after having created the project, you will need to re-launch the server to view that page. From the package&#39;s directory, activate it (<code>activate .</code>), then load (<code>using MyGenieApp</code>), create the server (<code>MyGenieApp.main()</code>) and run (<code>up()</code>).</p><hr/><h2 id="Working-with-resources"><a class="docs-heading-anchor" href="#Working-with-resources">Working with resources</a><a id="Working-with-resources-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-resources" title="Permalink"></a></h2><p>Adding our code to the <code>routes.jl</code> file works great for small projects, where you want to quickly publish features on the web. But for larger projects we&#39;re better off using Genie&#39;s MVC structure (MVC stands for Model-View-Controller). By employing the Model-View-Controller design pattern we can break our code into modules with clear responsibilities: the Model is used for data access, the View renders the response to the client, and the Controller orchestrates the interactions between Models and Views and handles requests. Modular code is easier to write, test and maintain.</p><p>A Genie app can be architected around the concept of &quot;resources&quot;. A resource represents a business entity (something like a user, or a product, or an account) and maps to a bundle of files (controller, model, views, etc). Resources live under the <code>app/resources/</code> folder and each resource has its own dedicated folder, where all of its files are hosted. For example, if we have a web app about &quot;books&quot;, a &quot;books&quot; folder would be found at <code>app/resources/books</code> and will contain all the files for publishing books on the web (usually called <code>BooksController.jl</code> for the controller, <code>Books.jl</code> for the model, <code>BooksValidator.jl</code> for the model validator – as well as a <code>views</code> folder for hosting all the view files necessary for rendering books data).</p><hr/><p><strong>HEADS UP</strong></p><p>When creating a default Genie app, the <code>app/</code> folder might be missing. It will be automatically created the first time you add a resource via Genie&#39;s generators.</p><hr/><h2 id="Using-Controllers"><a class="docs-heading-anchor" href="#Using-Controllers">Using Controllers</a><a id="Using-Controllers-1"></a><a class="docs-heading-anchor-permalink" href="#Using-Controllers" title="Permalink"></a></h2><p>Controllers are used to orchestrate interactions between client requests, Models (which handle data access), and Views (which are responsible for rendering the responses which will be sent to the clients&#39; web browsers). In a standard workflow, a <code>route</code> points to a method in the controller – which is charged with building and sending the response over the network, back to the client.</p><p>Let&#39;s add a &quot;books&quot; controller. Genie comes with handy generators and one of them is for creating new controllers:</p><h3 id="Generate-the-Controller"><a class="docs-heading-anchor" href="#Generate-the-Controller">Generate the Controller</a><a id="Generate-the-Controller-1"></a><a class="docs-heading-anchor-permalink" href="#Generate-the-Controller" title="Permalink"></a></h3><p>Let&#39;s generate our <code>BooksController</code>:</p><pre><code class="language-julia hljs">julia&gt; Genie.newcontroller(&quot;Books&quot;)
[info]: New controller created at ./app/resources/books/BooksController.jl</code></pre><p>Great! Let&#39;s edit <code>BooksController.jl</code> (<code>julia&gt; edit(&quot;./app/resources/books/BooksController.jl&quot;)</code>) and add something to it. For example, a function which returns some of Bill Gates&#39; recommended books would be nice. Make sure that <code>BooksController.jl</code> looks like this:</p><pre><code class="language-julia hljs"># app/resources/books/BooksController.jl
module BooksController

struct Book
  title::String
  author::String
end

const BillGatesBooks = Book[
  Book(&quot;The Best We Could Do&quot;, &quot;Thi Bui&quot;),
  Book(&quot;Evicted: Poverty and Profit in the American City&quot;, &quot;Matthew Desmond&quot;),
  Book(&quot;Believe Me: A Memoir of Love, Death, and Jazz Chickens&quot;, &quot;Eddie Izzard&quot;),
  Book(&quot;The Sympathizer&quot;, &quot;Viet Thanh Nguyen&quot;),
  Book(&quot;Energy and Civilization, A History&quot;, &quot;Vaclav Smil&quot;)
]

function billgatesbooks()
  &quot;&quot;&quot;
  &lt;h1&gt;Bill Gates&#39; list of recommended books&lt;/h1&gt;
  &lt;ul&gt;
    $([&quot; &lt;li&gt;$(book.title) by $(book.author)&lt;/li&gt;&quot; for book in BillGatesBooks]...)
  &lt;/ul&gt;
  &quot;&quot;&quot;
end

end</code></pre><p>Our controller is just a plain Julia module where we define a <code>Book</code> type/struct and set up an array of book objects. We then defined a function, <code>billgatesbooks</code>, which returns an HTML string, with a <code>H1</code> heading and an unordered list of all the books. We used an array comprehension to iterate over each book and render it in a <code>&lt;li&gt;</code> element. The elements of the array are then concatenated using the splat <code>...</code> operator. The plan is to map this function to a route and expose it on the internet.</p><h4 id="Checkpoint"><a class="docs-heading-anchor" href="#Checkpoint">Checkpoint</a><a id="Checkpoint-1"></a><a class="docs-heading-anchor-permalink" href="#Checkpoint" title="Permalink"></a></h4><p>Before exposing it on the web, we can test the function in the REPL:</p><pre><code class="language-julia hljs">julia&gt; using BooksController

julia&gt; BooksController.billgatesbooks()</code></pre><p>The output of the function call should be a HTML string which looks like this:</p><pre><code class="language-julia hljs">&quot;\n  &lt;h1&gt;Bill Gates&#39; list of recommended books&lt;/h1&gt;\n  &lt;ul&gt;\n    &lt;li&gt;The Best We Could Do by Thi Bui&lt;/li&gt;&lt;li&gt;Evicted: Poverty and Profit in the American City by Matthew Desmond&lt;/li&gt;&lt;li&gt;Believe Me: A Memoir of Love, Death, and Jazz Chickens by Eddie Izzard&lt;/li&gt;&lt;li&gt;The Sympathizer by Viet Thanh Nguyen&lt;/li&gt;&lt;li&gt;Energy and Civilization, A History by Vaclav Smil&lt;/li&gt;\n  &lt;/ul&gt;\n&quot;</code></pre><p>Please make sure that it works as expected.</p><h2 id="Setup-the-route"><a class="docs-heading-anchor" href="#Setup-the-route">Setup the route</a><a id="Setup-the-route-1"></a><a class="docs-heading-anchor-permalink" href="#Setup-the-route" title="Permalink"></a></h2><p>Now, let&#39;s expose our <code>billgatesbooks</code> method on the web. We need to add a new <code>route</code> which points to it. Add these to the <code>routes.jl</code> file:</p><pre><code class="language-julia hljs"># routes.jl
using Genie.Router
using BooksController

route(&quot;/bgbooks&quot;) do
  BooksController.billgatesbooks()
end</code></pre><p>In the snippet we declared that we&#39;re <code>using BooksController</code> (notice that Genie will know where to find it, no need to explicitly include the file) and then we defined a <code>route</code> between <code>/bgbooks</code> and the <code>BooksController.billgatesbooks</code> function (we say that the <code>BooksController.billgatesbooks</code> is the route handler for the <code>/bgbooks</code> URL or endpoint).</p><p>That&#39;s all! If you now visit <code>http://localhost:8000/bgbooks</code> you&#39;ll see Bill Gates&#39; list of recommended books (well, at least some of them, the man reads a lot!).</p><hr/><p><strong>PRO TIP</strong></p><p>If you would rather work with Julia instead of wrangling HTML strings, you can use Genie&#39;s <code>Html</code> API. It provides functions which map every standard HTML element. For instance, the <code>BooksController.billgatesbooks</code> function can be written as follows, as an array of HTML elements:</p><pre><code class="language-julia hljs">using Genie.Renderer.Html

function billgatesbooks_gen()
  [
    Html.h1() do
      &quot;Bill Gates&#39; list of recommended books&quot;
    end
    Html.ul() do
      for_each(BillGatesBooks) do book
        Html.li() do
          book.title * &quot; by &quot; * book.author
        end
      end
    end
  ]
end</code></pre><p>The <code>for_each</code> macro iterates over a collection and concatenates the output of each loop into the result of the loop. We&#39;ll talk about it more soon.</p><p>Adding the following route to <code>routes.jl</code> will create a new page with an identical output.</p><pre><code class="language-julia hljs"># routes.jl

route(&quot;/bgbooks_gen&quot;) do
  BooksController.billgatesbooks_gen()
end</code></pre><hr/><h2 id="Views"><a class="docs-heading-anchor" href="#Views">Views</a><a id="Views-1"></a><a class="docs-heading-anchor-permalink" href="#Views" title="Permalink"></a></h2><p>However, putting HTML into the controllers is a bad idea: HTML should stay in the dedicated view files and contain as little logic as possible. Let&#39;s refactor our code to use views instead.</p><h3 id="Adding-views"><a class="docs-heading-anchor" href="#Adding-views">Adding views</a><a id="Adding-views-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-views" title="Permalink"></a></h3><p>The views used for rendering a resource should be placed inside the <code>views/</code> folder, within that resource&#39;s own folder structure. So in our case, we will add an <code>app/resources/books/views/</code> folder. Just go ahead and do it, Genie does not provide a generator for this task:</p><pre><code class="language-julia hljs">julia&gt; mkdir(joinpath(&quot;app&quot;, &quot;resources&quot;, &quot;books&quot;, &quot;views&quot;))
&quot;app/resources/books/views&quot;</code></pre><p>We created the <code>views/</code> folder in <code>app/resources/books/</code>. We provided the full path as our REPL is running in the the root folder of the app. Also, we use the <code>joinpath</code> function so that Julia creates the path in a cross-platform way.</p><h3 id="Naming-views"><a class="docs-heading-anchor" href="#Naming-views">Naming views</a><a id="Naming-views-1"></a><a class="docs-heading-anchor-permalink" href="#Naming-views" title="Permalink"></a></h3><p>Usually each controller method will have its own rendering logic – hence, its own view file. Thus, it&#39;s a good practice to name the view files just like the methods, so that we can keep track of where they&#39;re used.</p><p>At the moment, Genie supports HTML and Markdown view files, as well as plain Julia. Their type is identified by file extension so that&#39;s an important part. The HTML views use a <code>.jl.html</code> extension while the Markdown files go with <code>.jl.md</code> and the Julia ones by <code>.jl</code>.</p><h3 id="Taking-advantage-of-layouts"><a class="docs-heading-anchor" href="#Taking-advantage-of-layouts">Taking advantage of layouts</a><a id="Taking-advantage-of-layouts-1"></a><a class="docs-heading-anchor-permalink" href="#Taking-advantage-of-layouts" title="Permalink"></a></h3><p>Before exploring the HTML and Markdown views, we need to add a layout.</p><p>Genie&#39;s views are rendered within a layout file. Layouts are meant to render the theme of the website, or the &quot;frame&quot; around the view – the elements which are common on all the pages. The layout file can include visible elements, like the main menu or the footer. But also maybe the <code>&lt;head&gt;</code> tag or the assets tags (<code>&lt;link&gt;</code> and <code>&lt;script&gt;</code> tags for loading CSS and JavaScript files in all the pages).</p><p>Every Genie app has a main layout file which is used by default. The <code>Genie.newapp()</code> template generator will not create this file. Create a new subdirectory <code>app/layouts/</code> and open a new file <code>app.jl.html</code>. Insert the following generic content:</p><pre><code class="language-html hljs">&lt;!-- app/layouts/app.jl.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot; /&gt;
    &lt;title&gt;Genie :: The highly productive Julia web framework&lt;/title&gt;
    &lt;!-- link rel=&quot;stylesheet&quot; href=&quot;/css/application.css&quot; / --&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;%
      @yield
    %&gt;
    &lt;!-- script src=&quot;/js/application.js&quot;&gt;&lt;/script --&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre><p>We can edit it. For example, add this right under the opening <code>&lt;body&gt;</code> tag, just before the <code>&lt;%</code> tag:</p><pre><code class="language-html hljs">&lt;h1&gt;Welcome to top books&lt;/h1&gt;</code></pre><h3 id="HTML-views"><a class="docs-heading-anchor" href="#HTML-views">HTML views</a><a id="HTML-views-1"></a><a class="docs-heading-anchor-permalink" href="#HTML-views" title="Permalink"></a></h3><p>All right then, let&#39;s add our first view file for the <code>BooksController.billgatesbooks</code> method. Let&#39;s create an HTML view file. With Julia:</p><pre><code class="language-julia hljs">julia&gt; touch(joinpath(&quot;app&quot;, &quot;resources&quot;, &quot;books&quot;, &quot;views&quot;, &quot;billgatesbooks.jl.html&quot;))</code></pre><p>Genie supports a special type of dynamic HTML view, where we can embed Julia code. These are high performance compiled views. They are <em>not</em> parsed as strings: instead, <strong>the HTML is converted to native Julia rendering code which is cached to the file system and loaded like any other Julia file</strong>. Hence, the first time you load a view, or after you change one, you might notice a certain delay – it&#39;s the time needed to generate, compile and load the view. On next runs (especially in production) it&#39;s going to be blazing fast!</p><p>Now all we need to do is to move the HTML code out of the controller and into the view, improving it a bit to also show a count of the number of books. Edit the view file as follows (<code>julia&gt; edit(&quot;app/resources/books/views/billgatesbooks.jl.html&quot;)</code>):</p><pre><code class="language-html hljs">&lt;!-- billgatesbooks.jl.html --&gt;
&lt;h1&gt;Bill Gates&#39; top $(length(books)) recommended books&lt;/h1&gt;
&lt;ul&gt;
  &lt;% for_each(books) do book %&gt;
    &lt;li&gt;$(book.title) by $(book.author)&lt;/li&gt;
  &lt;% end %&gt;
&lt;/ul&gt;</code></pre><p>As you can see, it&#39;s just plain HTML with embedded Julia. We can add Julia code by using the <code>&lt;% ... %&gt;</code> code block tags – these should be used for more complex, multiline expressions. Or by using plain Julia string interpolation with <code>$(...)</code> – for simple values outputting.</p><p>To make HTML generation more efficient, Genie provides a series of helpers, like the above <code>for_each</code> macro which allows iterating over a collection, passing the current item into the processing function.</p><hr/><p><strong>HEADS UP</strong></p><p><strong>It is very important to keep in mind that Genie views work by rendering a HTML string. Thus, the Julia view code <em>must return a string</em> as its result, so that the output of the computation comes up on the page</strong>. Given that Julia automatically returns the result of the last computation, most of the times this just flows naturally. But if sometimes you notice that the templates don&#39;t output what is expected, do check that the code returns a string (or something which can be converted to a string).</p><hr/><h3 id="Rendering-views"><a class="docs-heading-anchor" href="#Rendering-views">Rendering views</a><a id="Rendering-views-1"></a><a class="docs-heading-anchor-permalink" href="#Rendering-views" title="Permalink"></a></h3><p>We now need to expand our controller to use the view, passing in the expected variables. We will use the <code>html</code> method which renders and outputs the response as HTML. Create a new definition of the <code>billgatesbooks</code> function to be as follows:</p><pre><code class="language-julia hljs"># BooksController.jl

function billgatesbooks_view()
  html(:books, :billgatesbooks, books = BillGatesBooks)
end</code></pre><p>First, notice that we needed to add <code>Genie.Renderer.Html</code> as a dependency, to get access to the <code>html</code> method. As for the <code>html</code> method itself, it takes as its arguments the name of the resource, the name of the view file, and a list of keyword arguments representing view variables:</p><ul><li><code>:books</code> is the name of the resource (which effectively indicates in which <code>views</code> folder Genie should look for the view file – in our case <code>app/resources/books/views</code>);</li><li><code>:billgatesbooks</code> is the name of the view file. We don&#39;t need to pass the extension, Genie will figure it out since there&#39;s only one file with this name;</li><li>and finally, we pass the values we want to expose in the view, as keyword arguments.</li></ul><p>Next, we again add a route to <code>routes.jl</code>:</p><pre><code class="language-julia hljs"># routes.jl

route(&quot;/bgbooks_view&quot;) do
  BooksController.billgatesbooks_view()
end</code></pre><p>That&#39;s it – our refactored app including a layout and a new view should be ready! You can try it out for yourself at <a href="http://localhost:8000/bgbooks_view">http://localhost:8000/bgbooks_view</a>.</p><h3 id="Alternative-layout"><a class="docs-heading-anchor" href="#Alternative-layout">Alternative layout</a><a id="Alternative-layout-1"></a><a class="docs-heading-anchor-permalink" href="#Alternative-layout" title="Permalink"></a></h3><p>Naturally, we don&#39;t have to stick to the default; we can add additional layouts. Let&#39;s suppose that we have, for example, an admin area which should have a completely different theme. We can add a dedicated layout for that:</p><pre><code class="language-julia hljs">julia&gt; touch(joinpath(&quot;app&quot;, &quot;layouts&quot;, &quot;admin.jl.html&quot;))

&quot;app/layouts/admin.jl.html&quot;</code></pre><p>Now edit it (<code>julia&gt; edit(&quot;app/layouts/admin.jl.html&quot;)</code>) and make it look like this:</p><pre><code class="language-html hljs">&lt;!-- app/layouts/admin.jl.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;title&gt;Genie Admin&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Books admin&lt;/h1&gt;
    &lt;%
      @yield
    %&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre><p>If we want to apply it, we must instruct our <code>BooksController</code> to use it. The <code>html</code> function takes a keyword argument named <code>layout</code>, for the layout file. Update the list of <code>billgatesbooks...()</code> functions and the routes with these:</p><pre><code class="language-julia hljs"># BooksController.jl
function billgatesbooks_view_admin()
  html(:books, :billgatesbooks, books = BillGatesBooks, layout = :admin)
end</code></pre><pre><code class="language-julia hljs"># routes.jl
route(&quot;/bgbooks_view&quot;) do
  BooksController.billgatesbooks_view_admin()
end</code></pre><p>Reload the page and you&#39;ll see the new heading.</p><h3 id="Markdown-views"><a class="docs-heading-anchor" href="#Markdown-views">Markdown views</a><a id="Markdown-views-1"></a><a class="docs-heading-anchor-permalink" href="#Markdown-views" title="Permalink"></a></h3><p>Markdown views work similar to HTML views – employing the same embedded Julia functionality. Here is how you can add a Markdown view for our <code>billgatesbooks...()</code> functions.</p><p>First, create the corresponding view file, using the <code>.jl.md</code> extension. Maybe with:</p><pre><code class="language-julia hljs">julia&gt; touch(joinpath(&quot;app&quot;, &quot;resources&quot;, &quot;books&quot;, &quot;views&quot;, &quot;billgatesbooks.jl.md&quot;))</code></pre><p>Now edit the file and make sure it looks like this:</p><pre><code class="language-md hljs">&lt;!-- app/resources/books/views/billgatesbooks.jl.md --&gt;
# Bill Gates&#39; $(length(books)) recommended books

$(
  for_each(books) do book
    &quot;* $(book.title) by $(book.author) \n&quot;
  end
)</code></pre><p>Notice that Markdown views do not support Genie&#39;s embedded Julia tags <code>&lt;% ... %&gt;</code>. Only string interpolation <code>$(...)</code> is accepted, but it works across multiple lines.</p><p>If you reload the page now, however, Genie will still load the HTML view. The reason is that, <em>if we have only one view file</em>, Genie will manage. But if there&#39;s more than one, the framework won&#39;t know which one to pick. It won&#39;t error out but will pick the preferred one, which is the HTML version.</p><p>It&#39;s a simple change in the <code>BookiesController</code>: we have to explicitly tell Genie which file to load, extension and all:</p><pre><code class="language-julia hljs"># BooksController.jl
function billgatesbooks_view_md()
  html(:books, &quot;billgatesbooks.jl.md&quot;, books = BillGatesBooks)
end</code></pre><pre><code class="language-julia hljs"># routes.jl
route(&quot;/bgbooks_view_md&quot;) do
  BooksController.billgatesbooks_view_md()
end</code></pre><hr/><p><strong>HEADS UP</strong></p><p>Note that the rendered web page will include the comment <code>&lt;!-- app/resources/books/views/billgatesbooks.jl.md --&gt;</code> which is currently not removed when generating the HTML page.</p><hr/><hr/><p><strong>WARNING</strong></p><p>The top of the file reads:</p><pre><code class="language-md hljs">&lt;!-- app/resources/books/views/billgatesbooks.jl.md --&gt;
# Bill Gates&#39; $(length(books)) recommended books</code></pre><p>If empty lines are inserted</p><hr/><h4 id="The-@yield-instruction"><a class="docs-heading-anchor" href="#The-@yield-instruction">The <code>@yield</code> instruction</a><a id="The-@yield-instruction-1"></a><a class="docs-heading-anchor-permalink" href="#The-@yield-instruction" title="Permalink"></a></h4><p>There is a special instruction in the layouts: <code>@yield</code>. It outputs the contents of the view as rendered through the controller. So where this macro is present, Genie will output the HTML resulting from rendering the view by executing the route handler function within the controller.</p><h4 id="Using-view-paths"><a class="docs-heading-anchor" href="#Using-view-paths">Using view paths</a><a id="Using-view-paths-1"></a><a class="docs-heading-anchor-permalink" href="#Using-view-paths" title="Permalink"></a></h4><p>For very simple applications the MVC and the resource-centric approaches might involve too much boilerplate. In such cases, we can simplify the code by referencing the view (and layout) by file path, ex:</p><pre><code class="language-julia hljs"># BooksController.jl
using Genie.Renderer.Html

function billgatesbooks_view()
  html(path&quot;app/resources/books/views/billgatesbooks.jl.html&quot;, books = BillGatesBooks, layout = path&quot;app/layouts/app.jl.html&quot;)

  # This is equivalent to:
  # html(path&quot;app/resources/books/views/billgatesbooks.jl.html&quot;, books = BillGatesBooks, layout = :app)
end</code></pre><h3 id="Rendering-JSON-views"><a class="docs-heading-anchor" href="#Rendering-JSON-views">Rendering JSON views</a><a id="Rendering-JSON-views-1"></a><a class="docs-heading-anchor-permalink" href="#Rendering-JSON-views" title="Permalink"></a></h3><p>A common use case for web apps is to serve as backends for RESTful APIs. For this cases, JSON is the preferred data format. You&#39;ll be happy to hear that Genie has built-in support for JSON responses. Let&#39;s add an endpoint for our API – which will render Bill Gates&#39; books as JSON.</p><p>We can start in the <code>routes.jl</code> file, by appending this</p><pre><code class="language-julia hljs">route(&quot;/api/v1/bgbooks&quot;) do
  BooksController.API.billgatesbooks_json()
end</code></pre><p>Next, in <code>BooksController.jl</code>, append the extra logic at the end of the file, and replace the final <code>end</code> closing the <code>BooksController</code> module definition. The end of the file should look like this:</p><pre><code class="language-julia hljs"># BooksController.jl
module BooksController

.correct
.
.
BLA BLA BLA
.
.
.

# This is necessary to correct an outstanding issue described in [https://github.com/GenieFramework/Genie.jl/issues/397]().
using StructTypes
StructTypes.StructType(::Type{Book}) = StructTypes.Struct()

momodule API
using ..BooksController
using Genie.Renderer.Json

function billgatesbooks_view_json()
   json(BooksController.BillGatesBooks)
end

end # Module API

end # Module BooksController</code></pre><p>We nested an API module within the <code>BooksController</code> module, where we defined another <code>billgatesbooks</code> function which outputs a JSON.</p><hr/><p><strong>HEADS UP</strong></p><p>(November 2021) The temporary line is added (<code>StructTypes.StructType(::Type{Book}) = StructTypes.Struct()</code>). This is necessary to correct an outstanding issue described in <a href="guides/">https://github.com/GenieFramework/Genie.jl/issues/397</a>.</p><hr/><p>After the usual routes addition:</p><pre><code class="language-julia hljs">route(&quot;/api/v1/bgbooks&quot;) do
  BooksController.API.billgatesbooks_view_json()
end</code></pre><p>If you go to <code>http://localhost:8000/api/v1/bgbooks</code> it should already work as expected.</p><h4 id="JSON-views"><a class="docs-heading-anchor" href="#JSON-views">JSON views</a><a id="JSON-views-1"></a><a class="docs-heading-anchor-permalink" href="#JSON-views" title="Permalink"></a></h4><p>However, we have just committed one of the cardinal sins of API development. We have just forever coupled our internal data structure to its external representation. This will make future refactoring very complicated and error prone as any changes in the data will break the client&#39;s integrations. The solution is to, again, use views, to fully control how we render our data – and decouple the data structure from its rendering on the web.</p><p>Genie has support for JSON views – these are plain Julia files which have the &quot;.json.jl&quot; extension. Let&#39;s add one in our <code>views/</code> folder:</p><pre><code class="language-julia hljs">julia&gt; touch(joinpath(&quot;app&quot;, &quot;resources&quot;, &quot;books&quot;, &quot;views&quot;, &quot;billgatesbooks.json.jl&quot;))
&quot;app/resources/books/views/billgatesbooks.json.jl&quot;&lt;</code></pre><p>We can now create a proper response. Put this in the view file:</p><pre><code class="language-julia hljs"># app/resources/books/views/billgatesbooks.json.jl
&quot;Bill Gates&#39; list of recommended books&quot; =&gt; books</code></pre><p>Final step, to instruct <code>BooksController</code> to render the view, add a <code>billgatesbooks_json_view</code> function within the <code>API</code> sub-module with the following:</p><pre><code class="language-julia hljs">function billgatesbooks_json_view2()
  json(:books, :billgatesbooks, books = BooksController.BillGatesBooks)
end</code></pre><pre><code class="language-julia hljs"># route.jl
route(&quot;/api/v2/bgbooks&quot;) do
  BooksController.API.billgatesbooks_view_json2()
end</code></pre><p>This should hold no surprises – the <code>json</code> function is similar to the <code>html</code> one we&#39;ve seen before. So now we&#39;re rendering a custom JSON response. That&#39;s all – everything should work on <code>http://localhost:8000/api/v2/bgbooks</code>!</p><hr/><p><strong>HEADS UP</strong></p><h4 id="Why-JSON-views-have-the-extension-ending-in-.jl-but-HTML-and-Markdown-views-do-not?"><a class="docs-heading-anchor" href="#Why-JSON-views-have-the-extension-ending-in-.jl-but-HTML-and-Markdown-views-do-not?">Why JSON views have the extension ending in <code>.jl</code> but HTML and Markdown views do not?</a><a id="Why-JSON-views-have-the-extension-ending-in-.jl-but-HTML-and-Markdown-views-do-not?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-JSON-views-have-the-extension-ending-in-.jl-but-HTML-and-Markdown-views-do-not?" title="Permalink"></a></h4><p>Good question! The extension of the views is chosen in order to preserve correct syntax highlighting in the IDE/code editor.</p><p>Since practically HTML and Markdown views are HTML and Markdown files with some embedded Julia code, we want to use the HTML or Markdown syntax highlighting. For JSON views, we use pure Julia, so we want Julia syntax highlighting.</p><hr/><h2 id="Accessing-databases-with-SearchLight-models"><a class="docs-heading-anchor" href="#Accessing-databases-with-SearchLight-models">Accessing databases with <code>SearchLight</code> models</a><a id="Accessing-databases-with-SearchLight-models-1"></a><a class="docs-heading-anchor-permalink" href="#Accessing-databases-with-SearchLight-models" title="Permalink"></a></h2><p>You can get the most out of Genie by pairing it with its seamless ORM layer, SearchLight. SearchLight, a native Julia ORM, provides excellent support for working with relational databases. The Genie + SearchLight combo can be used to productively develop CRUD (Create-Read-Update-Delete) apps.</p><hr/><p><strong>HEADS UP</strong></p><p>CRUD stands for Create-Read-Update-Delete and describes the data workflow in many web apps, where resources are created, read (listed), updated, and deleted.</p><hr/><p>SearchLight represents the &quot;M&quot; part in Genie&#39;s MVC architecture (thus, the Model layer).</p><p>Let&#39;s begin by adding SearchLight to our Genie app. All Genie apps manage their dependencies in their own Julia environment, through their <code>Project.toml</code> and <code>Manifest.toml</code> files.</p><p>So we need to make sure that we&#39;re in <code>pkg&gt;</code> shell mode first (which is entered by typing <code>]</code> in julian mode, ie: <code>julia&gt;]</code>). The cursor should change to <code>(MyGenieApp) pkg&gt;</code>.</p><p>Next, we add <code>SearchLight</code>:</p><pre><code class="language-julia hljs">(MyGenieApp) pkg&gt; add SearchLight</code></pre><h3 id="Adding-a-database-adapter"><a class="docs-heading-anchor" href="#Adding-a-database-adapter">Adding a database adapter</a><a id="Adding-a-database-adapter-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-a-database-adapter" title="Permalink"></a></h3><p><code>SearchLight</code> provides a database agnostic API for working with various backends (at the moment, MySQL, SQLite, and Postgres). Thus, we also need to add the specific adapter. To keep things simple, let&#39;s use SQLite for our app. Hence, we&#39;ll need the <code>SearchLightSQLite</code> package:</p><pre><code class="language-julia hljs">(MyGenieApp) pkg&gt; add SearchLightSQLite SQLite</code></pre><h3 id="Setup-the-database-connection"><a class="docs-heading-anchor" href="#Setup-the-database-connection">Setup the database connection</a><a id="Setup-the-database-connection-1"></a><a class="docs-heading-anchor-permalink" href="#Setup-the-database-connection" title="Permalink"></a></h3><p>Genie is designed to seamlessly integrate with SearchLight and provides access to various database oriented generators. First we need to tell Genie/SearchLight how to connect to the database. Let&#39;s use them to set up our database support. Run this in the Genie/Julia REPL:</p><pre><code class="language-julia hljs">julia&gt; Genie.Generator.db_support()</code></pre><p>The command will add a <code>db/</code> folder within the root of the app. What we&#39;re looking for is the <code>db/connection.yml</code> file which tells SearchLight how to connect to the database.</p><p>It is initally clean:</p><pre><code class="language-julia hljs">julia&gt; using SQLite, SearchLight

julia&gt; SearchLight.Configuration.load()

Dict{String, Any} with 8 entries:
  &quot;options&quot;  =&gt; Dict{String, String}()
  &quot;host&quot;     =&gt; nothing
  &quot;password&quot; =&gt; nothing
  &quot;config&quot;   =&gt; nothing
  &quot;username&quot; =&gt; nothing
  &quot;port&quot;     =&gt; nothing
  &quot;database&quot; =&gt; nothing
  &quot;adapter&quot;  =&gt; nothing</code></pre><p>Let&#39;s edit it (it is initially write-protected and your editor might complain about this). Make the file look like this:</p><pre><code class="language-yaml hljs">env: ENV[&quot;GENIE_ENV&quot;]

dev:
  adapter: SQLite
  database: db/books.sqlite
  config:</code></pre><p>This instructs SearchLight to run in the environment of the current Genie app (by default <code>dev</code>), using <code>SQLite</code> for the adapter (backend) and a database stored at <code>db/books.sqlite</code> (the database will be created automatically if it does not exist). We could pass extra configuration options in the <code>config</code> object, but for now we don&#39;t need anything else.</p><hr/><p><strong>HEADS UP</strong></p><p>If you are using a different adapter, make sure that the database configured already exists and that the configured user can successfully access it – SearchLight will not attempt to create the database.</p><p>The environment variable <code>GENIE_ENV</code> selects one of the profiles in the <code>yml</code> file.</p><hr/><p>Now we can ask SearchLight to load it up and add it to the list of connextion:</p><pre><code class="language-julia hljs">julia&gt; push!(SearchLightSQLite.CONNECTIONS, SQLite.DB(SearchLight.Configuration.load()[&quot;database&quot;]))
1-element Vector{SQLite.DB}:
 SQLite.DB(&quot;db/books.sqlite&quot;)</code></pre><p>The connection succeeded and we got back a SQLite database handle added to the list of databases connections.</p><hr/><p><strong>PRO TIP</strong></p><p>Each database adapter exposes a <code>CONNECTIONS</code> collection where we can access the connection:</p><pre><code class="language-julia hljs">julia&gt; SearchLightSQLite.CONNECTIONS
1-element Array{SQLite.DB,1}:
 SQLite.DB(&quot;db/books.sqlite&quot;)</code></pre><hr/><p>Awesome! If all went well you should have a <code>books.sqlite</code> database in the <code>db/</code> folder (from the Julia REPL prompt, typing <code>;</code> will give the shell prompt).</p><pre><code class="language-julia hljs">shell&gt; tree db
db
├── books.sqlite
├── connection.yml
├── migrations
└── seeds</code></pre><h3 id="Managing-the-database-schema-with-SearchLight-migrations"><a class="docs-heading-anchor" href="#Managing-the-database-schema-with-SearchLight-migrations">Managing the database schema with <code>SearchLight</code> migrations</a><a id="Managing-the-database-schema-with-SearchLight-migrations-1"></a><a class="docs-heading-anchor-permalink" href="#Managing-the-database-schema-with-SearchLight-migrations" title="Permalink"></a></h3><p>Database migrations provide a way to reliably, consistently and repeatedly apply (and undo) schema transformations. They are specialised scripts for adding, removing and altering DB tables – these scripts are placed under version control and are managed by a dedicated system which knows which scripts have been run and which not, and is able to run them in the correct order.</p><p>SearchLight needs its own DB table to keep track of the state of the migrations so let&#39;s set it up:</p><pre><code class="language-julia hljs">julia&gt; SearchLight.Migrations.create_migrations_table()
[ Info: Created table schema_migrations</code></pre><p>This command sets up our database with the needed table in order to manage migrations.</p><hr/><p><strong>PRO TIP</strong></p><p>You can use the SearchLight API to execute random queries against the database backend. For example we can confirm that the table is really there:</p><pre><code class="language-julia hljs">julia&gt; SearchLight.query(&quot;SELECT name FROM sqlite_master WHERE type =&#39;table&#39; AND name NOT LIKE &#39;sqlite_%&#39;&quot;)
┌ Info: SELECT name FROM sqlite_master WHERE type =&#39;table&#39; AND name NOT LIKE &#39;sqlite_%&#39;
└

1×1 DataFrames.DataFrame
│ Row │ name              │
│     │ String⍰           │
├─────┼───────────────────┤
│ 1   │ schema_migrations │</code></pre><p>The result is a familiar <code>DataFrame</code> object.</p><hr/><h3 id="Creating-our-Book-model"><a class="docs-heading-anchor" href="#Creating-our-Book-model">Creating our Book model</a><a id="Creating-our-Book-model-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-our-Book-model" title="Permalink"></a></h3><p>SearchLight, just like Genie, uses the convention-over-configuration design pattern. It prefers for things to be setup in a certain way and provides sensible defaults, versus having to define everything in extensive configuration files. And fortunately, we don&#39;t even have to remember what these conventions are, as SearchLight also comes with an extensive set of generators.</p><p>Lets ask SearchLight to create a new model:</p><pre><code class="language-julia hljs">julia&gt; SearchLight.Generator.newresource(&quot;Book&quot;)

[ Info: New model created at [PROJECT DIRECTORY]/MyGenieApp/app/resources/books/Books.jl
[ Info: New table migration created at [PROJECT DIRECTORY]/MyGenieApp/db/migrations/2020020909574048_create_table_books.jl
[ Info: New validator created at [PROJECT DIRECTORY]/MyGenieApp/app/resources/books/BooksValidator.jl
[ Info: New unit test created at [PROJECT DIRECTORY]/MyGenieApp/test/books_test.jl</code></pre><p>SearchLight has created the <code>Books.jl</code> model, the <code>*_create_table_books.jl</code> migration file, the <code>BooksValidator.jl</code> model validator and the <code>books_test.jl</code> test file.</p><hr/><p><strong>HEADS UP</strong></p><p>The first part of the migration file will be different for you!</p><p>The text returned by the command will vary slightly depending on your personal setup. The <code>*_create_table_books.jl</code> file will be named differently as the first part of the name is the file creation timestamp. This timestamp part guarantees that names are unique and file name clashes are avoided (for example when working as a team a creating similar migration files).</p><hr/><h4 id="Writing-the-table-migration"><a class="docs-heading-anchor" href="#Writing-the-table-migration">Writing the table migration</a><a id="Writing-the-table-migration-1"></a><a class="docs-heading-anchor-permalink" href="#Writing-the-table-migration" title="Permalink"></a></h4><p>Lets begin by writing the migration to create our books table. SearchLight provides a powerful DSL for writing migrations. Each migration file needs to define two methods: <code>up</code> which applies the changes – and <code>down</code> which undoes the effects of the <code>up</code> method. So in our <code>up</code> method we want to create the table – and in <code>down</code> we want to drop the table.</p><p>The naming convention for tables in SearchLight is that the table name should be pluralized (<code>books</code>) – because a table contains multiple books (each row represents an object, a &quot;book&quot;). But don&#39;t worry, the migration file should already be pre-populated with the correct table name.</p><p>Edit the <code>db/migrations/*_create_table_books.jl</code> file and make it look like this:</p><pre><code class="language-julia hljs">module CreateTableBooks

import SearchLight.Migrations: create_table, column, primary_key, add_index, drop_table

function up()
  create_table(:books) do
    [
      primary_key()
      column(:title, :string, limit = 100)
      column(:author, :string, limit = 100)
    ]
  end

  add_index(:books, :title)
  add_index(:books, :author)
end

function down()
  drop_table(:books)
end

end</code></pre><p>The DSL is pretty readable: in the <code>up</code> function we call <code>create_table</code> and pass an array of columns: a primary key, a <code>title</code> column and an <code>author</code> column (both strings have a max length of 100). We also add two indices (one on the <code>title</code> and the other on the <code>author</code> columns). As for the <code>down</code> method, it invokes the <code>drop_table</code> function to remove the table.</p><h4 id="Running-the-migration"><a class="docs-heading-anchor" href="#Running-the-migration">Running the migration</a><a id="Running-the-migration-1"></a><a class="docs-heading-anchor-permalink" href="#Running-the-migration" title="Permalink"></a></h4><p>We can see what SearchLight knows about our migrations with the <code>SearchLight.Migrations.status()</code> command:</p><pre><code class="language-julia hljs">julia&gt; SearchLight.Migrations.status()
|   | Module name &amp; status                   |
|   | File name                              |
|---|----------------------------------------|
|   |                 CreateTableBooks: DOWN |
| 1 | 2020020909574048_create_table_books.jl |</code></pre><p>So our migration is in the <code>down</code> state – meaning that its <code>up</code> method has not been run. We can easily fix this:</p><pre><code class="language-julia hljs">julia&gt; SearchLight.Migrations.last_up()
[ Info: Executed migration CreateTableBooks up</code></pre><p>If we recheck the status, the migration is up:</p><pre><code class="language-julia hljs">julia&gt; SearchLight.Migrations.status()
|   | Module name &amp; status                   |
|   | File name                              |
|---|----------------------------------------|
|   |                   CreateTableBooks: UP |
| 1 | 2020020909574048_create_table_books.jl |</code></pre><p>Our table is ready!</p><hr/><p><strong>PRO TIP</strong></p><p>If using Visual Code, using an SQLite extension such as <a href="https://marketplace.visualstudio.com/items?itemName=alexcvzz.vscode-sqlite">SQLite</a> is a good way to follow the database internal changes.</p><hr/><h4 id="Defining-the-model"><a class="docs-heading-anchor" href="#Defining-the-model">Defining the model</a><a id="Defining-the-model-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-model" title="Permalink"></a></h4><p>Now it&#39;s time to edit our model file at <code>app/resources/books/Books.jl</code>. Another convention in SearchLight is that we&#39;re using the pluralized name (<code>Books</code>) for the module – because it&#39;s for managing multiple books. And within it we define a type (a <code>mutable struct</code>), called <code>Book</code> – which represents an item (a single book) which maps to a row in the underlying database.</p><p>Edit the <code>Books.jl</code> file to make it look like this:</p><pre><code class="language-julia hljs"># Books.jl
module Books

import SearchLight: AbstractModel, DbId, save!

# @kwdef is not exported by Base and, theoretically, should not be used since it is an internal symbol.
# If you want, you could instead use the @with_kw macro from the Parameters.jl package.
import Base: @kwdef

export Book

@kwdef mutable struct Book &lt;: AbstractModel
  id::DbId = DbId()
  title::String = &quot;&quot;
  author::String = &quot;&quot;
end

end</code></pre><p>We defined a <code>mutable struct</code> which matches our previous <code>Book</code> type by using the <code>@kwdef</code> macro, in order to also define a keyword constructor, as SearchLight needs it.</p><h4 id="Using-our-model"><a class="docs-heading-anchor" href="#Using-our-model">Using our model</a><a id="Using-our-model-1"></a><a class="docs-heading-anchor-permalink" href="#Using-our-model" title="Permalink"></a></h4><p>To make things more interesting, we should import our current books into the database. Add this function to the <code>Books.jl</code> module, following the <code>Book()</code> constructor definition (just above the module&#39;s closing <code>end</code>):</p><pre><code class="language-julia hljs"># Books.jl
function seed()
  BillGatesBooks = [
    (&quot;The Best We Could Do&quot;, &quot;Thi Bui&quot;),
    (&quot;Evicted: Poverty and Profit in the American City&quot;, &quot;Matthew Desmond&quot;),
    (&quot;Believe Me: A Memoir of Love, Death, and Jazz Chickens&quot;, &quot;Eddie Izzard&quot;),
    (&quot;The Sympathizer!&quot;, &quot;Viet Thanh Nguyen&quot;),
    (&quot;Energy and Civilization, A History&quot;, &quot;Vaclav Smil&quot;)
  ]

  for b in BillGatesBooks
    Book(title = b[1], author = b[2]) |&gt; save!
  end
end</code></pre><h4 id="Auto-loading-the-DB-configuration"><a class="docs-heading-anchor" href="#Auto-loading-the-DB-configuration">Auto-loading the DB configuration</a><a id="Auto-loading-the-DB-configuration-1"></a><a class="docs-heading-anchor-permalink" href="#Auto-loading-the-DB-configuration" title="Permalink"></a></h4><p>Now, to try things out. Genie takes care of loading all our resource files for us when we load the app. To do this, Genie comes with a special file called an initializer, which automatically loads the database configuration and sets up SearchLight. Check <code>config/initializers/searchlight.jl</code>. It should look like this:</p><pre><code class="language-julia hljs">using SearchLight

try
  SearchLight.Configuration.load()

  if SearchLight.config.db_config_settings[&quot;adapter&quot;] !== nothing
    eval(Meta.parse(&quot;using SearchLight$(SearchLight.config.db_config_settings[&quot;adapter&quot;])&quot;))
    SearchLight.connect()

    @eval begin
      using Genie.Renderer.Json

      function Genie.Renderer.Json.JSON3.StructTypes.StructType(::Type{T}) where {T&lt;:SearchLight.AbstractModel}
        Genie.Renderer.Json.JSON3.StructTypes.Struct()
      end

      function Genie.Renderer.Json.JSON3.StructTypes.StructType(::Type{SearchLight.DbId})
        Genie.Renderer.Json.JSON3.StructTypes.Struct()
      end
    end
  end
catch ex
  @error ex
end</code></pre><hr/><p><strong>Heads up!</strong></p><p>All the <code>*.jl</code> files placed into the <code>config/initializers/</code> folder are automatically included by Genie upon starting the Genie app. They are included early (upon initialisation), before the controllers, models, views, are loaded.</p><hr/><h4 id="Trying-it-out"><a class="docs-heading-anchor" href="#Trying-it-out">Trying it out</a><a id="Trying-it-out-1"></a><a class="docs-heading-anchor-permalink" href="#Trying-it-out" title="Permalink"></a></h4><p>Now it&#39;s time to restart our REPL session and test our app. Close the Julia REPL session to exit to the OS command line and run:</p><pre><code class="language-bash hljs">$ bin/repl</code></pre><p>In Windows go into the <code>bin/</code> folder within the application&#39;s directory and run <code>repl.bat</code> in the terminal.</p><p>The <code>repl</code> executable script placed within the app&#39;s <code>bin/</code> folder starts a new Julia REPL session and loads the applications&#39; environment. Everything should be automatically loaded now, DB configuration included - so we can invoke the previously defined <code>seed</code> function to insert the books:</p><pre><code class="language-julia hljs">julia&gt; using Books

julia&gt; Books.seed()</code></pre><p>There should be a list of queries showing how the data is inserted in the DB:</p><pre><code class="language-julia hljs">julia&gt; Books.seed()
[ Info: INSERT  INTO books (&quot;title&quot;, &quot;author&quot;) VALUES (&#39;The Best We Could Do&#39;, &#39;Thi Bui&#39;)
[ Info: INSERT  INTO books (&quot;title&quot;, &quot;author&quot;) VALUES (&#39;Evicted: Poverty and Profit in the American City&#39;, &#39;Matthew Desmond&#39;)
# output truncated</code></pre><p>If you want to make sure all went right (although trust me, it did, otherwise SearchLight would&#39;ve thrown an <code>Exception</code>!), just ask SearchLight to retrieve them:</p><pre><code class="language-julia hljs">julia&gt; using SearchLight

julia&gt; all(Book)
[ Info: 2020-02-09 13:29:32 SELECT &quot;books&quot;.&quot;id&quot; AS &quot;books_id&quot;, &quot;books&quot;.&quot;title&quot; AS &quot;books_title&quot;, &quot;books&quot;.&quot;author&quot; AS &quot;books_author&quot; FROM &quot;books&quot; ORDER BY books.id ASC

5-element Array{Book,1}:
 Book
| KEY            | VALUE                |
|----------------|----------------------|
| author::String | Thi Bui              |
| id::DbId       | 1                    |
| title::String  | The Best We Could Do |

 Book
| KEY            | VALUE                                            |
|----------------|--------------------------------------------------|
| author::String | Matthew Desmond                                  |
| id::DbId       | 2                                                |
| title::String  | Evicted: Poverty and Profit in the American City |

# output truncated</code></pre><p>The <code>SearchLight.all</code> method returns all the <code>Book</code> items from the database.</p><p>All good!</p><p>The next thing we need to do is to update our controller to use the model. Make sure that <code>app/resources/books/BooksController.jl</code> reads like this:</p><pre><code class="language-julia hljs"># BooksController.jl
module BooksController

using Genie.Renderer.Html, SearchLight, Books

function billgatesbooks_sqlite()
  html(:books, :billgatesbooks, books = all(Book))
end

module API

using ..BooksController
using Genie.Renderer.Json, SearchLight, Books

function billgatesbooks_view_sqlite()
  json(:books, :billgatesbooks_sqlite, books = all(Book))
end

end

end</code></pre><p>Our JSON view needs a bit of tweaking too. let&#39;s create a new view file <code>billgatesbooks_sqlite.json.jl</code> with the following content:</p><pre><code class="language-julia hljs"># app/resources/books/views/billgatesbooks_sqlite.json.jl
&quot;Bill&#39;s Gates list of recommended books&quot; =&gt; [Dict(&quot;author&quot; =&gt; b.author, &quot;title&quot; =&gt; b.title) for b in books]</code></pre><hr/><p><strong>Heads up!</strong></p><p>In the sub-module <code>API</code>, the parameter <code>:billgatesbooks_sqlite</code> reflects the new file named <code>billgatesbooks_sqlite.json.jl</code>!</p><hr/><p>Let&#39;s also add a new route:</p><pre><code class="language-julia hljs"># route.jl
route(&quot;/api/v3/bgbooks&quot;) do
  BooksController.API.billgatesbooks_view_sqlite()
end</code></pre><p>Now if we just start the server we&#39;ll be able to see the list of books served from the database:</p><pre><code class="language-julia hljs"># Start the server
julia&gt; up()</code></pre><p>The <code>up</code> method starts up the web server and takes us back to the interactive Julia REPL prompt.</p><p>Now, if, for example, we navigate to <a href="http://localhost:8000/api/v3/bgbooks">http://localhost:8000/api/v3/bgbooks</a>, the output should match the following JSON document (edited with newlines for clarity):</p><pre><code class="language-json hljs">{
  &quot;Bill&#39;s Gates list of recommended books&quot;: [
    {
      &quot;author&quot;: &quot;Thi Bui&quot;,
      &quot;title&quot;: &quot;The Best We Could Do&quot;
    },
    {
      &quot;author&quot;: &quot;Matthew Desmond&quot;,
      &quot;title&quot;: &quot;Evicted: Poverty and Profit in the American City&quot;
    },
    {
      &quot;author&quot;: &quot;Eddie Izzard&quot;,
      &quot;title&quot;: &quot;Believe Me: A Memoir of Love, Death, and Jazz Chickens&quot;
    },
    {
      &quot;author&quot;: &quot;Viet Thanh Nguyen&quot;,
      &quot;title&quot;: &quot;The Sympathizer!&quot;
    },
    {
      &quot;author&quot;: &quot;Vaclav Smil&quot;,
      &quot;title&quot;: &quot;Energy and Civilization, A History&quot;
    }
  ]
}</code></pre><p>Let&#39;s add a new book to see how it works. We&#39;ll create a new <code>Book</code> item and persist it using the <code>SearchLight.save!</code> method:</p><pre><code class="language-julia hljs">julia&gt; newbook = Book(title = &quot;Leonardo da Vinci&quot;, author = &quot;Walter Isaacson&quot;)

Book
| KEY            | VALUE             |
|----------------|-------------------|
| author::String | Walter Isaacson   |
| id::DbId       | NULL              |
| title::String  | Leonardo da Vinci |


julia&gt; save!(newbook)

[ Info: INSERT  INTO books (&quot;title&quot;, &quot;author&quot;) VALUES (&#39;Leonardo da Vinci&#39;, &#39;Walter Isaacson&#39;)
[ Info: ; SELECT CASE WHEN last_insert_rowid() = 0 THEN -1 ELSE last_insert_rowid() END AS id
[ Info: SELECT &quot;books&quot;.&quot;id&quot; AS &quot;books_id&quot;, &quot;books&quot;.&quot;title&quot; AS &quot;books_title&quot;, &quot;books&quot;.&quot;author&quot; AS &quot;books_author&quot; FROM &quot;books&quot; WHERE &quot;id&quot; = 6 ORDER BY books.id ASC

Book
| KEY            | VALUE             |
|----------------|-------------------|
| author::String | Walter Isaacson   |
| id::DbId       | 6                 |
| title::String  | Leonardo da Vinci |</code></pre><p>Calling the <code>save!</code> method, SearchLight has persisted the object in the database and then retrieved it and returned it (notice the updated <code>id::DbId</code> field).</p><p>The same <code>save!</code> operation can be written as a one-liner:</p><pre><code class="language-julia hljs">julia&gt; Book(title = &quot;Leonardo da Vinci&quot;, author = &quot;Walter Isaacson&quot;) |&gt; save!</code></pre><hr/><p><strong>HEADS UP</strong></p><p>If you also run the one-liner <code>save!</code> example, it will add the same book again. No problem, but if you want to remove it, you can use the <code>delete</code> method:</p><pre><code class="language-julia hljs">julia&gt; delete(ans)
[ Info: DELETE FROM books WHERE id = &#39;7&#39;

Book
| KEY            | VALUE             |
|----------------|-------------------|
| author::String | Walter Isaacson   |
| id::DbId       | NULL              |
| title::String  | Leonardo da Vinci |</code></pre><hr/><p>If you reload the page at <a href="http://localhost:8000/api/v3/bgbooks">http://localhost:8000/api/v3/bgbooks</a> the new book should show up.</p><pre><code class="language-json hljs">{
  &quot;Bill&#39;s Gates list of recommended books&quot;: [
    {
      &quot;author&quot;: &quot;Thi Bui&quot;,
      &quot;title&quot;: &quot;The Best We Could Do&quot;
    },
    {
      &quot;author&quot;: &quot;Matthew Desmond&quot;,
      &quot;title&quot;: &quot;Evicted: Poverty and Profit in the American City&quot;
    },
    {
      &quot;author&quot;: &quot;Eddie Izzard&quot;,
      &quot;title&quot;: &quot;Believe Me: A Memoir of Love, Death, and Jazz Chickens&quot;
    },
    {
      &quot;author&quot;: &quot;Viet Thanh Nguyen&quot;,
      &quot;title&quot;: &quot;The Sympathizer!&quot;
    },
    {
      &quot;author&quot;: &quot;Vaclav Smil&quot;,
      &quot;title&quot;: &quot;Energy and Civilization, A History&quot;
    },
    {
      &quot;author&quot;: &quot;Walter Isaacson&quot;,
      &quot;title&quot;: &quot;Leonardo da Vinci&quot;
    }
  ]
}</code></pre><hr/><p><strong>PRO TIP</strong></p><p>SearchLight exposes two similar data persistence methods: <code>save!</code> and <code>save</code>. They both perform the same action (persisting the object to the database), but <code>save</code> will return a <code>Bool</code> <code>true</code> to indicate that the operation was successful or a <code>Bool</code> <code>false</code> to indicate that the operation has failed. While the <code>save!</code> variant will return the persisted object upon success or will throw an exception on failure.</p><hr/><h2 id="Congratulations"><a class="docs-heading-anchor" href="#Congratulations">Congratulations</a><a id="Congratulations-1"></a><a class="docs-heading-anchor-permalink" href="#Congratulations" title="Permalink"></a></h2><p>You have successfully finished the first part of the step by step walkthrough - you now master the Genie basics, allowing you to set up a new app, register routes, add resources (controllers, models, and views), add database support, version the database schema with migrations, and execute basic queries with SearchLight!</p><p>In the next part we&#39;ll look at more advanced topics like handling forms and file uploads, templates rendering, interactivity and more.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../index.html">« Home</a><a class="docs-footer-nextpage" href="Interactive_environment.html">Using Genie in an interactive environment »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Thursday 18 November 2021 14:58">Thursday 18 November 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
