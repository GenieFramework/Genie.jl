<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Advanced routing · Genie - The Highly Productive Julia Web Framework</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Genie - The Highly Productive Julia Web Framework</span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><span class="tocitem">Guides</span><ul><li><a class="tocitem" href="../guides/Working_With_Genie_Apps.html">Working with Genie Apps</a></li><li><a class="tocitem" href="../guides/Interactive_environment.html">Using Genie in an interactive environment</a></li><li><a class="tocitem" href="../guides/Simple_API_backend.html">Developing an API backend</a></li><li><a class="tocitem" href="../guides/Genie_Plugins.html">Using Genie Plugins</a></li><li><a class="tocitem" href="../guides/Working_With_Genie_Apps_Intermediary_Topics.html">Working With Genie Apps: Intermediate Topics [WIP]</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="1--Overview.html">Welcome to Genie</a></li><li><a class="tocitem" href="2--Installing_Genie.html">Installing Genie</a></li><li><a class="tocitem" href="3--Getting_Started.html">Getting started</a></li><li><a class="tocitem" href="4--Developing_Web_Services.html">Creating a web service</a></li><li><a class="tocitem" href="4-1--Developing_MVC_Web_Apps.html">Developing MVC web applications</a></li><li><a class="tocitem" href="5--Handling_Query_Params.html">Handling URI/query params</a></li><li><a class="tocitem" href="6--Working_with_POST_Payloads.html">Working with forms and POST payloads</a></li><li><a class="tocitem" href="7--Using_JSON_Payloads.html">Using JSON payloads</a></li><li><a class="tocitem" href="8--Handling_File_Uploads.html">Uploading files</a></li><li><a class="tocitem" href="9--Publishing_Your_Julia_Code_Online_With_Genie_Apps.html">Adding your libraries into Genie</a></li><li><a class="tocitem" href="10--Loading_Genie_Apps.html">Loading and starting Genie apps</a></li><li><a class="tocitem" href="11--Managing_External_Packages.html">Managing Genie app&#39;s dependencies</a></li><li class="is-active"><a class="tocitem" href="12--Advanced_Routing_Techniques.html">Advanced routing</a><ul class="internal"><li><a class="tocitem" href="#Static-routing"><span>Static routing</span></a></li><li><a class="tocitem" href="#Dynamic-routing-(using-route-parameters)"><span>Dynamic routing (using route parameters)</span></a></li><li><a class="tocitem" href="#Routing-methods-(GET,-POST,-PUT,-PATCH,-DELETE,-OPTIONS)"><span>Routing methods (<code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>PATCH</code>, <code>DELETE</code>, <code>OPTIONS</code>)</span></a></li><li><a class="tocitem" href="#Named-routes"><span>Named routes</span></a></li><li><a class="tocitem" href="#Links-to-routes"><span>Links to routes</span></a></li><li><a class="tocitem" href="#Listing-routes"><span>Listing routes</span></a></li><li><a class="tocitem" href="#Removing-routes"><span>Removing routes</span></a></li><li><a class="tocitem" href="#Matching-routes-by-type-of-arguments"><span>Matching routes by type of arguments</span></a></li><li><a class="tocitem" href="#Matching-individual-URI-segments"><span>Matching individual URI segments</span></a></li><li><a class="tocitem" href="#The-@params-collection"><span>The <code>@params</code> collection</span></a></li></ul></li><li><a class="tocitem" href="13--Initializers.html">Auto-loading configuration code with initializers</a></li><li><a class="tocitem" href="14--The_Secrets_File.html">The secrets file</a></li><li><a class="tocitem" href="15--The_Lib_Folder.html">Auto-loading user libraries</a></li><li><a class="tocitem" href="16--Using_Genie_With_Docker.html">Using Genie with Docker</a></li><li><a class="tocitem" href="17--Working_with_Web_Sockets.html">Working with WebSockets</a></li><li><a class="tocitem" href="80--Force_Compiling_Routes.html">Force compiling route handlers</a></li><li><a class="tocitem" href="90--Deploying_With_Heroku_Buildpacks.html">Deploying to Heroku with Buildpacks</a></li><li><a class="tocitem" href="91--Deploying_Genie_Docker_Apps_on_Heroku.html">Deploying to Heroku with Docker</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../API/app.html">App</a></li><li><a class="tocitem" href="../API/appserver.html">AppServer</a></li><li><a class="tocitem" href="../API/assets.html">Assets</a></li><li><a class="tocitem" href="../API/cache.html">Cache</a></li><li><a class="tocitem" href="../API/commands.html">Commands</a></li><li><a class="tocitem" href="../API/configuration.html">Configuration</a></li><li><a class="tocitem" href="../API/cookies.html">Cookies</a></li><li><a class="tocitem" href="../API/deploy_docker.html">Deploy Docker</a></li><li><a class="tocitem" href="../API/deploy_heroku.html">Deploy Heroku</a></li><li><a class="tocitem" href="../API/encryption.html">Encryption</a></li><li><a class="tocitem" href="../API/exceptions.html">Exceptions</a></li><li><a class="tocitem" href="../API/filetemplates.html">FileTemplates</a></li><li><a class="tocitem" href="../API/flash.html">Flash</a></li><li><a class="tocitem" href="../API/generator.html">Generator</a></li><li><a class="tocitem" href="../API/genie.html">Genie</a></li><li><a class="tocitem" href="../API/headers.html">Headers</a></li><li><a class="tocitem" href="../API/httputils.html">HttpUtils</a></li><li><a class="tocitem" href="../API/inflector.html">Inflector</a></li><li><a class="tocitem" href="../API/input.html">Input</a></li><li><a class="tocitem" href="../API/plugins.html">Plugins</a></li><li><a class="tocitem" href="../API/renderer.html">Renderer</a></li><li><a class="tocitem" href="../API/renderer_html.html">HTML Renderer</a></li><li><a class="tocitem" href="../API/renderer_js.html">JS Renderer</a></li><li><a class="tocitem" href="../API/renderer_json.html">JSON Renderer</a></li><li><a class="tocitem" href="../API/requests.html">Requests</a></li><li><a class="tocitem" href="../API/responses.html">Responses</a></li><li><a class="tocitem" href="../API/router.html">Router</a></li><li><a class="tocitem" href="../API/sessions.html">Sessions</a></li><li><a class="tocitem" href="../API/toolbox.html">Toolbox</a></li><li><a class="tocitem" href="../API/util.html">Util</a></li><li><a class="tocitem" href="../API/webchannels.html">WebChannels</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href="12--Advanced_Routing_Techniques.html">Advanced routing</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="12--Advanced_Routing_Techniques.html">Advanced routing</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/GenieFramework/Genie.jl/blob/master/docs/src/tutorials/12--Advanced_Routing_Techniques.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Advanced-routing-techniques"><a class="docs-heading-anchor" href="#Advanced-routing-techniques">Advanced routing techniques</a><a id="Advanced-routing-techniques-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-routing-techniques" title="Permalink"></a></h1><p>Genie&#39;s router can be considered the brain of the app, matching web requests to functions, extracting and setting up the request&#39;s variables and the execution environment, and invoking the response methods. Such power is accompanied by a powerful set of features for defining routes. Let&#39;s dive into these.</p><h2 id="Static-routing"><a class="docs-heading-anchor" href="#Static-routing">Static routing</a><a id="Static-routing-1"></a><a class="docs-heading-anchor-permalink" href="#Static-routing" title="Permalink"></a></h2><p>Starting with the simplest case, we can register &quot;plain&quot; routes by using the <code>route</code> method. The method takes as its required arguments the URI pattern and the function that should be invoked in order to provide the response. The router supports two ways of registering routes, either <code>route(pattern::String, f::Function)</code> or <code>route(f::Function, pattern::String)</code>. The first syntax is for passing function references – while the second is for defining inline function.</p><h3 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h3><p>The following snippet defines a function <code>greet</code> which returns the &quot;Welcome to Genie!&quot; string. We use the function as our route handler, by passing it as the second argument to the <code>route</code> method.</p><pre><code class="language-julia">using Genie, Genie.Router

greet() = &quot;Welcome to Genie!&quot;

route(&quot;/greet&quot;, greet)          # [GET] /greet =&gt; greet

up() # start the server</code></pre><p>If you use your browser to navigate to <a href="http://127.0.0.1:8000/greet">http://127.0.0.1:8000/greet</a> you&#39;ll see the code in action.</p><p>However, defining a dedicated handler function might be overkill for simple cases like this. As such, Genie allows registering in-line handlers:</p><pre><code class="language-julia">route(&quot;/bye&quot;) do
  &quot;Good bye!&quot;
end                 # [GET] /bye =&gt; getfield(Main, Symbol(&quot;##3#4&quot;))()</code></pre><p>You can just navigate to <a href="http://127.0.0.1:8000/bye">http://127.0.0.1:8000/bye</a> – the route is instantly available in the app.</p><hr/><p><strong>HEADS UP</strong></p><p>The routes are added in the order in which they are defined but are matched from newest to oldest. This means that you can define a new route to overwrite a previously defined one.</p><p>Unlike Julia&#39;s multiple dispatch, Genie&#39;s router won&#39;t match the most specific rule, but the first matching one. So if, for example, you register a route to match <code>/*</code>, it will handle all the requests, even if you have previously defined more specific routes. As a side-note, you can use this technique to temporarily divert all users to a maintenance page.</p><hr/><h2 id="Dynamic-routing-(using-route-parameters)"><a class="docs-heading-anchor" href="#Dynamic-routing-(using-route-parameters)">Dynamic routing (using route parameters)</a><a id="Dynamic-routing-(using-route-parameters)-1"></a><a class="docs-heading-anchor-permalink" href="#Dynamic-routing-(using-route-parameters)" title="Permalink"></a></h2><p>Static routing works great for fixed URLs. But what if we have dynamic URLs, where the components map to information in the backend (like database IDs) and vary with each request? For example, how would we handle a URL like &quot;/customers/57943/orders/458230&quot;, where 57943 is the customer id and 458230 is the order id.</p><p>Such situations are handled through dynamic routing or route parameters. For the previous example, &quot;/customers/57943/orders/458230&quot;, we can define a dynamic route as &quot;/customers/:customer<em>id/orders/:order</em>id&quot;. Upon matching the request, the Router will unpack the values and expose them in the <code>@params</code> collection.</p><h3 id="Example-2"><a class="docs-heading-anchor" href="#Example-2">Example</a><a class="docs-heading-anchor-permalink" href="#Example-2" title="Permalink"></a></h3><pre><code class="language-julia">using Genie, Genie.Router, Genie.Requests

route(&quot;/customers/:customer_id/orders/:order_id&quot;) do
  &quot;You asked for the order $(payload(:order_id)) for customer $(payload(:customer_id))&quot;
end

up()</code></pre><h2 id="Routing-methods-(GET,-POST,-PUT,-PATCH,-DELETE,-OPTIONS)"><a class="docs-heading-anchor" href="#Routing-methods-(GET,-POST,-PUT,-PATCH,-DELETE,-OPTIONS)">Routing methods (<code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>PATCH</code>, <code>DELETE</code>, <code>OPTIONS</code>)</a><a id="Routing-methods-(GET,-POST,-PUT,-PATCH,-DELETE,-OPTIONS)-1"></a><a class="docs-heading-anchor-permalink" href="#Routing-methods-(GET,-POST,-PUT,-PATCH,-DELETE,-OPTIONS)" title="Permalink"></a></h2><p>By default, routes handle <code>GET</code> requests, since these are the most common. In order to define routes for handling other types of request methods, we need to pass the <code>method</code> keyword argument, indicating the HTTP method. Genie&#39;s Router supports <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>PATCH</code>, <code>DELETE</code>, <code>OPTIONS</code> methods.</p><p>The router defines and exports constants for each of these as <code>Router.GET</code>, <code>Router.POST</code>, <code>Router.PUT</code>, <code>Router.PATCH</code>, <code>Router.DELETE</code>, and <code>Router.OPTIONS</code>.</p><h3 id="Example-3"><a class="docs-heading-anchor" href="#Example-3">Example</a><a class="docs-heading-anchor-permalink" href="#Example-3" title="Permalink"></a></h3><p>We can setup the following <code>PATCH</code> route:</p><pre><code class="language-julia">using Genie, Genie.Router, Genie.Requests

route(&quot;/patch_stuff&quot;, method = PATCH) do
  &quot;Stuff to patch&quot;
end

up()</code></pre><p>And we can test it using the <code>HTTP</code> package:</p><pre><code class="language-julia">using HTTP

HTTP.request(&quot;PATCH&quot;, &quot;http://127.0.0.1:8000/patch_stuff&quot;).body |&gt; String
2019-08-19 14:23:46:INFO:Main: /patch_stuff 200

&quot;Stuff to patch&quot;</code></pre><p>By sending a request with the <code>PATCH</code> method, our route is triggered. Consequently, we access the response body and convert it to a string, which is &quot;Stuff to patch&quot;, corresponding to our response.</p><h2 id="Named-routes"><a class="docs-heading-anchor" href="#Named-routes">Named routes</a><a id="Named-routes-1"></a><a class="docs-heading-anchor-permalink" href="#Named-routes" title="Permalink"></a></h2><p>Genie allows tagging routes with names. This is a very powerful feature, to be used in conjunction with the <code>Router.tolink</code> method, for dynamically generating URLs towards the routes. The advantage of this technique is that if we refer the route by name and generate the links dynamically using <code>tolink</code>, as long as the name of the route stays the same, if we change the route pattern, all the URLs will automatically match the new route definiton.</p><p>In order to name a route we need to use the <code>named</code> keyword argument, which expects a <code>Symbol</code>.</p><h3 id="Example-4"><a class="docs-heading-anchor" href="#Example-4">Example</a><a class="docs-heading-anchor-permalink" href="#Example-4" title="Permalink"></a></h3><pre><code class="language-julia">using Genie, Genie.Router, Genie.Requests

route(&quot;/customers/:customer_id/orders/:order_id&quot;, named = :get_customer_order) do
  &quot;Looking up order $(payload(:order_id)) for customer  $(payload(:customer_id))&quot;
end         #  [GET] /customers/:customer_id/orders/:order_id =&gt; getfield(Main, Symbol(&quot;##5#6&quot;))()</code></pre><p>We can check the status of our route with:</p><pre><code class="language-julia">julia&gt; @routes
OrderedCollections.OrderedDict{Symbol,Genie.Router.Route} with 1 entry:
  :get_customer_order =&gt; [GET] /customers/:customer_id/orders/:order_id =&gt; getfield(Main, Symbol(&quot;##5#6&quot;))()</code></pre><hr/><p><strong>HEADS UP</strong></p><p>For consistency, Genie names all the routes. However, the auto-generated name is state dependent. So, if you change the route, it&#39;s possible that the name will change as well. Thus, it&#39;s best to explicitly name the routes if you plan on referencing them throughout the app.</p><hr/><p>We can confirm this by adding an anonymous route:</p><pre><code class="language-julia">route(&quot;/foo&quot;) do
  &quot;foo&quot;
end  #  [GET] /foo =&gt; getfield(Main, Symbol(&quot;##7#8&quot;))()

julia&gt; @routes
OrderedCollections.OrderedDict{Symbol,Genie.Router.Route} with 2 entries:
  :get_customer_order =&gt; [GET] /customers/:customer_id/orders/:order_id =&gt; getfield(Main, Symbol(&quot;##5#6&quot;))()
  :get_foo            =&gt; [GET] /foo =&gt; getfield(Main, Symbol(&quot;##7#8&quot;))()</code></pre><p>The new route has been automatically named <code>get_foo</code>, based on the method and URI pattern.</p><h2 id="Links-to-routes"><a class="docs-heading-anchor" href="#Links-to-routes">Links to routes</a><a id="Links-to-routes-1"></a><a class="docs-heading-anchor-permalink" href="#Links-to-routes" title="Permalink"></a></h2><p>We can use the name of the route to link back to it through the <code>linkto</code> method.</p><h3 id="Example-5"><a class="docs-heading-anchor" href="#Example-5">Example</a><a class="docs-heading-anchor-permalink" href="#Example-5" title="Permalink"></a></h3><p>Let&#39;s start with the previously defined two routes:</p><pre><code class="language-julia">julia&gt; @routes
OrderedCollections.OrderedDict{Symbol,Genie.Router.Route} with 2 entries:
  :get_customer_order =&gt; [GET] /customers/:customer_id/orders/:order_id =&gt; getfield(Main, Symbol(&quot;##5#6&quot;))()
  :get_foo            =&gt; [GET] /foo =&gt; getfield(Main, Symbol(&quot;##7#8&quot;))()</code></pre><p>Static routes such as <code>:get_foo</code> are straightforward to target:</p><pre><code class="language-julia">julia&gt; linkto(:get_foo)
&quot;/foo&quot;</code></pre><p>For dynamic routes, it&#39;s a bit more involved as we need to supply the values for each of the parameters, as keyword arguments:</p><pre><code class="language-julia">julia&gt; linkto(:get_customer_order, customer_id = 1234, order_id = 5678)
&quot;/customers/1234/orders/5678&quot;</code></pre><p>The <code>linkto</code> should be used in conjunction with the HTML code for generating links, ie:</p><pre><code class="language-html">&lt;a href=&quot;$(linkto(:get_foo))&quot;&gt;Foo&lt;/a&gt;</code></pre><h2 id="Listing-routes"><a class="docs-heading-anchor" href="#Listing-routes">Listing routes</a><a id="Listing-routes-1"></a><a class="docs-heading-anchor-permalink" href="#Listing-routes" title="Permalink"></a></h2><p>At any time we can check which routes are registered with <code>Router.routes</code>:</p><pre><code class="language-julia">julia&gt; routes()
2-element Array{Genie.Router.Route,1}:
 [GET] /foo =&gt; getfield(Main, Symbol(&quot;##7#8&quot;))()
 [GET] /customers/:customer_id/orders/:order_id =&gt; getfield(Main, Symbol(&quot;##5#6&quot;))()</code></pre><p>Or, we can use the previously discussed <code>@routes</code> macro:</p><pre><code class="language-julia">julia&gt; @routes
OrderedCollections.OrderedDict{Symbol,Genie.Router.Route} with 2 entries:
  :get_customer_order =&gt; [GET] /customers/:customer_id/orders/:order_id =&gt; getfield(Main, Symbol(&quot;##5#6&quot;))()
  :get_foo            =&gt; [GET] /foo =&gt; getfield(Main, Symbol(&quot;##7#8&quot;))()</code></pre><h3 id="The-Route-type"><a class="docs-heading-anchor" href="#The-Route-type">The <code>Route</code> type</a><a id="The-Route-type-1"></a><a class="docs-heading-anchor-permalink" href="#The-Route-type" title="Permalink"></a></h3><p>The routes are represented internally by the <code>Route</code> type which has 4 fields:</p><ul><li><code>method::String</code> - for storing the method of the route (<code>GET</code>, <code>POST</code>, etc)</li><li><code>path::String</code> - represents the URI pattern to be matched against</li><li><code>action::Function</code> - the route handler to be executed when the route is matched</li><li><code>name::Union{Symbol,Nothing}</code> - the name of the route</li></ul><h2 id="Removing-routes"><a class="docs-heading-anchor" href="#Removing-routes">Removing routes</a><a id="Removing-routes-1"></a><a class="docs-heading-anchor-permalink" href="#Removing-routes" title="Permalink"></a></h2><p>We can delete routes from the stack by calling the <code>delete!</code> method and passing the collection of routes and the name of the route to be removed. The method returns the collection of (remaining) routes</p><h3 id="Example-6"><a class="docs-heading-anchor" href="#Example-6">Example</a><a class="docs-heading-anchor-permalink" href="#Example-6" title="Permalink"></a></h3><pre><code class="language-julia">julia&gt; @routes
OrderedCollections.OrderedDict{Symbol,Genie.Router.Route} with 2 entries:
  :get_customer_order =&gt; [GET] /customers/:customer_id/orders/:order_id =&gt; getfield(Main, Symbol(&quot;##3#4&quot;))()
  :get_foo            =&gt; [GET] /foo =&gt; getfield(Main, Symbol(&quot;##9#10&quot;))()

julia&gt; Router.delete!(@routes, :get_foo)
OrderedCollections.OrderedDict{Symbol,Genie.Router.Route} with 1 entry:
  :get_customer_order =&gt; [GET] /customers/:customer_id/orders/:order_id =&gt; getfield(Main, Symbol(&quot;##3#4&quot;))()

julia&gt; @routes
OrderedCollections.OrderedDict{Symbol,Genie.Router.Route} with 1 entry:
  :get_customer_order =&gt; [GET] /customers/:customer_id/orders/:order_id =&gt; getfield(Main, Symbol(&quot;##3#4&quot;))()</code></pre><h2 id="Matching-routes-by-type-of-arguments"><a class="docs-heading-anchor" href="#Matching-routes-by-type-of-arguments">Matching routes by type of arguments</a><a id="Matching-routes-by-type-of-arguments-1"></a><a class="docs-heading-anchor-permalink" href="#Matching-routes-by-type-of-arguments" title="Permalink"></a></h2><p>By default route parameters are parsed into the <code>payload</code> collection as <code>SubString{String}</code>:</p><pre><code class="language-julia">using Genie, Genie.Router, Genie.Requests

route(&quot;/customers/:customer_id/orders/:order_id&quot;) do
  &quot;Order ID has type $(payload(:order_id) |&gt; typeof) // Customer ID has type $(payload(:customer_id) |&gt; typeof)&quot;
end</code></pre><p>This will output <code>Order ID has type SubString{String} // Customer ID has type SubString{String}</code></p><p>However, for such a case, we&#39;d very much prefer to receive our data as <code>Int</code> to avoid an explicit conversion – <em>and</em> to match only numbers. Genie supports such a workflow by allowing type annotations to route parameters:</p><pre><code class="language-julia">route(&quot;/customers/:customer_id::Int/orders/:order_id::Int&quot;, named = :get_customer_order) do
  &quot;Order ID has type $(payload(:order_id) |&gt; typeof) // Customer ID has type $(payload(:customer_id) |&gt; typeof)&quot;
end     #     [GET] /customers/:customer_id::Int/orders/:order_id::Int =&gt; getfield(Main, Symbol(&quot;##3#4&quot;))()</code></pre><p>Notice how we&#39;ve added type annotations to <code>:customer_id</code> and <code>:order_id</code> in the form <code>:customer_id::Int</code> and <code>:order_id::Int</code>.</p><p>However, attempting to access the URL <code>http://127.0.0.1:8000/customers/10/orders/20</code> will fail:</p><pre><code class="language-julia">Failed to match URI params between Int64::DataType and 10::SubString{String}
MethodError(convert, (Int64, &quot;10&quot;), 0x00000000000063fe)
/customers/10/orders/20 404</code></pre><p>As you can see, Genie attempts to convert the types from the default <code>SubString{String}</code> to <code>Int</code> – but doesn&#39;t know how. It fails, can&#39;t find other matching routes and returns a <code>404 Not Found</code> response.</p><h3 id="Type-conversion-in-routes"><a class="docs-heading-anchor" href="#Type-conversion-in-routes">Type conversion in routes</a><a id="Type-conversion-in-routes-1"></a><a class="docs-heading-anchor-permalink" href="#Type-conversion-in-routes" title="Permalink"></a></h3><p>The error is easy to address though: we need to provide a type converter from <code>SubString{String}</code> to <code>Int</code>.</p><pre><code class="language-julia">Base.convert(::Type{Int}, v::SubString{String}) = parse(Int, v)</code></pre><p>Once we register the converter in <code>Base</code>, our request will be correctly handled, resulting in <code>Order ID has type Int64 // Customer ID has type Int64</code></p><h2 id="Matching-individual-URI-segments"><a class="docs-heading-anchor" href="#Matching-individual-URI-segments">Matching individual URI segments</a><a id="Matching-individual-URI-segments-1"></a><a class="docs-heading-anchor-permalink" href="#Matching-individual-URI-segments" title="Permalink"></a></h2><p>Besides matching the full route, Genie also allows matching individual URI segments. That is, enforcing that the various route parameters obey a certain pattern. In order to introduce constraints for route parameters we append <code>#pattern</code> at the end of the route parameter.</p><h3 id="Example-7"><a class="docs-heading-anchor" href="#Example-7">Example</a><a class="docs-heading-anchor-permalink" href="#Example-7" title="Permalink"></a></h3><p>For instance, let&#39;s assume that we want to implement a localized website where we have a URL structure like: <code>mywebsite.com/en</code>, <code>mywebsite.com/es</code> and <code>mywebsite.com/de</code>. We can define a dynamic route and extract the locale variable to serve localized content:</p><pre><code class="language-julia">route(&quot;:locale&quot;, TranslationsController.index)</code></pre><p>This will work very well, matching requests and passing the locale into our code within the <code>payload(:locale)</code> variable. However, it will also be too greedy, virtually matching all the requests, including things like static files (ie <code>mywebsite.com/favicon.ico</code>). We can constrain what the <code>:locale</code> variable can match, by appending the pattern (a regex pattern):</p><pre><code class="language-julia">route(&quot;:locale#(en|es|de)&quot;, TranslationsController.index)</code></pre><p>The refactored route only allows <code>:locale</code> to match one of <code>en</code>, <code>es</code>, and <code>de</code> strings.</p><hr/><p><strong>HEADS UP</strong></p><p>Keep in mind not to duplicate application logic. For instance, if you have an array of supported locales, you can use that to dynamically generate the pattern – routes can be fully dynamically generated!</p><pre><code class="language-julia">const LOCALE = &quot;:locale#($(join(TranslationsController.AVAILABLE_LOCALES, &#39;|&#39;)))&quot;

route(&quot;/$LOCALE&quot;, TranslationsController.index, named = :get_index)</code></pre><hr/><h2 id="The-@params-collection"><a class="docs-heading-anchor" href="#The-@params-collection">The <code>@params</code> collection</a><a id="The-@params-collection-1"></a><a class="docs-heading-anchor-permalink" href="#The-@params-collection" title="Permalink"></a></h2><p>It&#39;s good to know that the router bundles all the parameters of the current request into the <code>@params</code> collection (a <code>Dict{Symbol,Any}</code>). This contains valuable information, such as route parameters, query params, POST payload, the original HTTP.Request and HTTP.Response objects, etcetera. In general it&#39;s recommended not to access the <code>@params</code> collection directly but through the utility methods defined by <code>Genie.Requests</code> and <code>Genie.Responses</code> – but knowing about <code>@params</code> might come in handy for advanced users.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="11--Managing_External_Packages.html">« Managing Genie app&#39;s dependencies</a><a class="docs-footer-nextpage" href="13--Initializers.html">Auto-loading configuration code with initializers »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 30 June 2020 17:54">Tuesday 30 June 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
